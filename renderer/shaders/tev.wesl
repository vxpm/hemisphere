import package::tev::{input, input::Input};
import package::uber;

const PLACEHOLDER_RGB: vec3f = vec3f(1.0, 0.0, 0.8627);
const PLACEHOLDER_RGBA: vec4f = vec4f(1.0, 0.0, 0.8627, 0.5);

alias Reg = u32;
const R3: Reg = 0;
const R0: Reg = 1;
const R1: Reg = 2;
const R2: Reg = 3;

// Configuration for a TEV operation.
struct OpConfig {
    input_a: Input,
    input_b: Input, 
    input_c: Input,
    input_d: Input,
    output: Reg,

    sign: f32,
    bias: f32,
    scale: f32,
    clamp: u32,
};

struct Refs {
    map: u32,
    coord: u32,
    color: u32,
};

// Configuration for a TEV stage, both color and alpha operations.
struct Stage {
    color: OpConfig, 
    alpha: OpConfig,
    refs: Refs,
};

/// All TEV stage configurations.
struct Config {
    count: u32,
    _pad0: u32,
    _pad1: u32,
    _pad2: u32,
    stages: array<Stage, 16>,
};

struct State {
    regs: array<vec4f, 4>,
    diffuse: vec4f,
    specular: vec4f,
    uv: vec2f,
}

/// Returns the value for the given input in the given state.
fn get_color_input(state: ptr<function, State>, value: Input) -> vec3f {
    switch value {
        // Registers
        case input::COLOR_R3C: {
            return state.regs[3].rgb;
        }
        case input::COLOR_R3A: {
            return state.regs[3].aaa;
        }
        case input::COLOR_R0C: {
            return state.regs[0].rgb;
        }
        case input::COLOR_R0A: {
            return state.regs[0].aaa;
        }
        case input::COLOR_R1C: {
            return state.regs[1].rgb;
        }
        case input::COLOR_R1A: {
            return state.regs[1].aaa;
        }
        case input::COLOR_R2C: {
            return state.regs[2].rgb;
        }
        case input::COLOR_R2A: {
            return state.regs[2].aaa;
        }

        // Texture colors
        case input::COLOR_TEX_COLOR: {
            let sample = textureSample(uber::texture0, uber::sampler0, state.uv);
            return sample.rgb;
        }
        case input::COLOR_TEX_ALPHA: {
            let sample = textureSample(uber::texture0, uber::sampler0, state.uv);
            return sample.aaa;
        }

        // Rasterizer colors
        case input::COLOR_RAS_COLOR: {
            return state.diffuse.rgb;
        }
        case input::COLOR_RAS_ALPHA: {
            return state.diffuse.aaa;
        }

        // Constants
        case input::COLOR_ONE: {
            return vec3f(1.0);
        }
        case input::COLOR_HALF: {
            return vec3f(0.5);
        }
        case input::COLOR_CONSTANT: {
            return PLACEHOLDER_RGB;
        }
        case input::COLOR_ZERO: {
            return vec3f(0.0);
        }

        default: {
            return PLACEHOLDER_RGB;
        }
    }
}

/// Returns the value for the given input in the given state.
fn get_alpha_input(state: ptr<function, State>, value: Input) -> f32 {
    switch value {
        // Registers
        case input::ALPHA_R3: {
            return state.regs[3].a;
        }
        case input::ALPHA_R0: {
            return state.regs[0].a;
        }
        case input::ALPHA_R1: {
            return state.regs[1].a;
        }
        case input::ALPHA_R2: {
            return state.regs[2].a;
        }

        // Texture colors
        case input::ALPHA_TEX: {
            let sample = textureSample(uber::texture0, uber::sampler0, state.uv);
            return sample.a;
        }

        // Rasterizer colors
        case input::ALPHA_RAS: {
            return state.diffuse.a;
        }

        // Constants
        case input::ALPHA_CONSTANT: {
            return PLACEHOLDER_RGBA.a;
        }
        case input::ALPHA_ZERO: {
            return 0.0;
        }

        default: {
            return PLACEHOLDER_RGBA.a;
        }
    }
}

fn compute_stage_color(a: vec3f, b: vec3f, c: vec3f, d: vec3f, sign: f32, bias: f32, scale: f32) -> vec3f {
    let lerp = sign * (a * (vec3f(1.0) - c) + b * c);
    return (lerp + d + bias) * scale;
}

fn compute_stage_alpha(a: f32, b: f32, c: f32, d: f32, sign: f32, bias: f32, scale: f32) -> f32 {
    let lerp = sign * (a * (1.0 - c) + b * c);
    return (lerp + d + bias) * scale;
}

fn compute(config: Config, diffuse: vec4f, specular: vec4f, uv: vec2f) -> vec4f {
    var state: State;
    state.diffuse = diffuse;
    state.specular = specular;
    state.uv = uv;

    var last_color_output = PLACEHOLDER_RGB;
    var last_alpha_output = 1.0;

    for (var i = 0u; i < config.count; i ++) {
        let stage = config.stages[i];

        let color_a = get_color_input(&state, stage.color.input_a);
        let color_b = get_color_input(&state, stage.color.input_b);
        let color_c = get_color_input(&state, stage.color.input_c);
        let color_d = get_color_input(&state, stage.color.input_d);
        let color = compute_stage_color(
            color_a,
            color_b,
            color_c,
            color_d,
            stage.color.sign,
            stage.color.bias,
            stage.color.scale
        );

        state.regs[stage.color.output].r = color.r;
        state.regs[stage.color.output].g = color.g;
        state.regs[stage.color.output].b = color.b;
        last_color_output = color;

        let alpha_a = get_alpha_input(&state, stage.alpha.input_a);
        let alpha_b = get_alpha_input(&state, stage.alpha.input_b);
        let alpha_c = get_alpha_input(&state, stage.alpha.input_c);
        let alpha_d = get_alpha_input(&state, stage.alpha.input_d);
        let alpha = compute_stage_alpha(
            alpha_a,
            alpha_b,
            alpha_c,
            alpha_d,
            stage.color.sign,
            stage.color.bias,
            stage.color.scale
        );

        state.regs[stage.alpha.output].a = alpha;
        last_alpha_output = alpha;
    }

    return vec4f(last_color_output, last_alpha_output);
}